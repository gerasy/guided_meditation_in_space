<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guided Meditation - Breathing in Space</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }

        /* Starfield background */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Main container */
        .container {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* Screens */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            max-width: 800px;
            width: 100%;
        }

        .screen.active {
            display: flex;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(100, 150, 255, 0.5);
        }

        h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #8af;
        }

        p {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #cce;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(135deg, #4a6cf7 0%, #6a4cf7 100%);
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 30px rgba(100, 100, 255, 0.4);
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 40px rgba(100, 100, 255, 0.6);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: linear-gradient(135deg, #3a4c87 0%, #4a3c87 100%);
        }

        /* Sphere container */
        .spheres-container {
            display: flex;
            gap: 80px;
            margin: 40px 0;
            align-items: center;
            justify-content: center;
        }

        .sphere-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .sphere-label {
            font-size: 1rem;
            color: #8af;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Sphere styling */
        .sphere {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at 30% 30%, #1a2a5a, #0a1030);
            box-shadow:
                0 0 60px rgba(100, 150, 255, 0.3),
                inset 0 0 60px rgba(50, 100, 200, 0.2);
            transition: transform 0.1s ease-out;
        }

        .sphere-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top,
                rgba(100, 200, 255, 0.8) 0%,
                rgba(150, 200, 255, 0.6) 50%,
                rgba(200, 220, 255, 0.4) 100%);
            transition: height 0.15s ease-out;
            border-radius: 0 0 90px 90px;
        }

        .sphere-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom,
                rgba(255, 255, 255, 0.4),
                transparent);
            border-radius: 50%;
            transform: translateY(-50%);
        }

        .sphere-glow {
            position: absolute;
            top: 10%;
            left: 15%;
            width: 30%;
            height: 30%;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            border-radius: 50%;
        }

        /* Guide sphere specific */
        .sphere.guide {
            border: 3px solid rgba(100, 200, 255, 0.5);
        }

        /* User sphere specific */
        .sphere.user {
            border: 3px solid rgba(150, 255, 150, 0.5);
        }

        .sphere.user .sphere-fill {
            background: linear-gradient(to top,
                rgba(100, 255, 150, 0.8) 0%,
                rgba(150, 255, 180, 0.6) 50%,
                rgba(200, 255, 220, 0.4) 100%);
        }

        /* Single sphere for calibration */
        .single-sphere {
            width: 200px;
            height: 200px;
        }

        /* Progress indicator */
        .progress-container {
            width: 100%;
            max-width: 400px;
            margin: 20px 0;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a6cf7, #8af);
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #aac;
        }

        /* Audio level indicator */
        .audio-level {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .audio-level-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f8, #8f4);
            transition: width 0.05s ease-out;
            width: 0%;
        }

        /* Instructions display */
        .instruction {
            font-size: 1.5rem;
            color: #fff;
            margin: 20px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
        }

        /* Calibration status */
        .calibration-status {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .calibration-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
        }

        .calibration-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #555;
        }

        .calibration-dot.complete {
            background: #4f8;
            box-shadow: 0 0 10px #4f8;
        }

        .calibration-dot.active {
            background: #ff8;
            box-shadow: 0 0 10px #ff8;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        /* Timer display */
        .timer {
            font-size: 3rem;
            font-weight: 300;
            color: #8af;
            margin: 10px 0;
        }

        /* Breathing phase indicator */
        .breathing-phase {
            font-size: 2rem;
            color: #8af;
            margin: 20px 0;
            min-height: 50px;
        }

        /* Score/feedback */
        .feedback {
            font-size: 1.2rem;
            color: #afc;
            margin: 10px 0;
            min-height: 30px;
        }

        /* Talking warning */
        .talking-warning {
            font-size: 1.1rem;
            color: #f66;
            margin: 5px 0;
            min-height: 25px;
            font-weight: bold;
        }

        /* Settings panel */
        .settings {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        .settings-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 10px 15px;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.2rem;
        }

        /* Round counter */
        .round-counter {
            font-size: 1rem;
            color: #8af;
            margin-bottom: 10px;
        }

        /* Timing info */
        .timing-info {
            font-size: 0.9rem;
            color: #aac;
            margin: 10px 0;
        }

        /* Completion screen */
        .completion-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
        }

        .stat-value {
            font-size: 2rem;
            color: #8af;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #aac;
            margin-top: 5px;
        }

        /* Debug panel */
        .debug-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 11px;
            color: #8f8;
            z-index: 1000;
            min-width: 220px;
        }

        .debug-panel h4 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 12px;
        }

        .debug-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        .debug-label {
            color: #aaa;
        }

        .debug-value {
            color: #8f8;
        }

        .debug-value.warning {
            color: #fa4;
        }

        .debug-value.good {
            color: #4f8;
        }

        .debug-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin: 5px 0;
            overflow: hidden;
        }

        .debug-bar-fill {
            height: 100%;
            background: #4f8;
            transition: width 0.1s;
        }

        /* Calibration results */
        .calibration-results {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            max-width: 500px;
        }

        .calibration-results h3 {
            color: #8af;
            margin-bottom: 15px;
        }

        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .result-row:last-child {
            border-bottom: none;
        }

        .result-label {
            color: #aac;
        }

        .result-value {
            color: #fff;
            font-weight: bold;
        }

        .adjustment-hint {
            margin-top: 15px;
            padding: 10px;
            background: rgba(100, 150, 255, 0.1);
            border-radius: 10px;
            font-size: 0.95rem;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel" style="display: none;">
        <h4>Audio Features</h4>
        <div class="debug-row">
            <span class="debug-label">Envelope:</span>
            <span class="debug-value" id="debug-envelope">0.00</span>
        </div>
        <div class="debug-bar"><div class="debug-bar-fill" id="debug-envelope-bar"></div></div>
        <div class="debug-row">
            <span class="debug-label">Slope:</span>
            <span class="debug-value" id="debug-slope">0.000</span>
        </div>
        <div class="debug-row">
            <span class="debug-label">Centroid:</span>
            <span class="debug-value" id="debug-centroid">0 Hz</span>
        </div>
        <div class="debug-row">
            <span class="debug-label">ZCR:</span>
            <span class="debug-value" id="debug-zcr">0.00</span>
        </div>
        <div class="debug-row">
            <span class="debug-label">Breath Score:</span>
            <span class="debug-value" id="debug-breath-score">0%</span>
        </div>
        <div class="debug-bar"><div class="debug-bar-fill" id="debug-score-bar" style="background: #4af;"></div></div>
        <div class="debug-row">
            <span class="debug-label">Phase:</span>
            <span class="debug-value" id="debug-phase">idle</span>
        </div>
        <div class="debug-row">
            <span class="debug-label">Talking:</span>
            <span class="debug-value" id="debug-talking">No</span>
        </div>
    </div>

    <div class="container">
        <!-- Welcome Screen -->
        <div class="screen active" id="welcome-screen">
            <h1>Breathing in Space</h1>
            <p>Welcome to your guided meditation journey through the cosmos.<br>
            We'll practice breathing exercises together, with visual guidance to help you sync your breath.</p>
            <p>This experience uses your microphone to detect your breathing patterns.<br>
            First, we'll calibrate the system to your unique breathing.</p>
            <button class="btn" id="start-btn">Begin Journey</button>
        </div>

        <!-- Microphone Permission Screen -->
        <div class="screen" id="permission-screen">
            <h2>Microphone Access</h2>
            <p>To detect your breathing, we need access to your microphone.<br>
            Your audio is processed locally and never leaves your device.</p>
            <button class="btn" id="permission-btn">Allow Microphone</button>
            <p id="permission-error" style="color: #f88; display: none;"></p>
        </div>

        <!-- Calibration Screen -->
        <div class="screen" id="calibration-screen">
            <h2>Calibration Setup</h2>

            <div class="calibration-status">
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-silence-dot"></div>
                    <span>Silence</span>
                </div>
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-talking-dot"></div>
                    <span>Talking</span>
                </div>
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-breathin-dot"></div>
                    <span>Breathe In</span>
                </div>
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-breathout-dot"></div>
                    <span>Breathe Out</span>
                </div>
            </div>

            <div class="instruction" id="calibration-instruction">
                Preparing calibration...
            </div>

            <div class="sphere single-sphere" id="calibration-sphere">
                <div class="sphere-fill" id="calibration-fill"></div>
                <div class="sphere-glow"></div>
            </div>

            <div class="audio-level">
                <div class="audio-level-fill" id="audio-level-fill"></div>
            </div>

            <div class="timing-info" id="timing-info"></div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="calibration-progress"></div>
                </div>
                <div class="progress-text" id="calibration-progress-text">Step 1 of 4</div>
            </div>
        </div>

        <!-- Ready Screen -->
        <div class="screen" id="ready-screen">
            <h2>Calibration Complete!</h2>

            <div class="calibration-results">
                <h3>Your Breathing Profile</h3>
                <div class="result-row">
                    <span class="result-label">Inhale Duration:</span>
                    <span class="result-value" id="result-inhale">0.0s</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Exhale Duration:</span>
                    <span class="result-value" id="result-exhale">0.0s</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Target Inhale:</span>
                    <span class="result-value" id="result-target-in">4.0s</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Target Exhale:</span>
                    <span class="result-value" id="result-target-out">4.0s</span>
                </div>
                <div class="adjustment-hint" id="adjustment-hint"></div>
            </div>

            <p>You'll see two spheres:<br>
            <strong style="color: #8af;">Blue</strong> - Follow this guide<br>
            <strong style="color: #8f8;">Green</strong> - Your detected breathing</p>
            <p>We'll gradually adjust to help you reach the target pace.</p>
            <button class="btn" id="begin-meditation-btn">Start Meditation</button>
        </div>

        <!-- Meditation Screen -->
        <div class="screen" id="meditation-screen">
            <div class="round-counter" id="round-counter">Round 1 of 5</div>

            <div class="breathing-phase" id="breathing-phase">Get Ready...</div>

            <div class="spheres-container">
                <div class="sphere-wrapper">
                    <div class="sphere-label">Guide</div>
                    <div class="sphere guide" id="guide-sphere">
                        <div class="sphere-fill" id="guide-fill"></div>
                        <div class="sphere-glow"></div>
                    </div>
                </div>
                <div class="sphere-wrapper">
                    <div class="sphere-label">You</div>
                    <div class="sphere user" id="user-sphere">
                        <div class="sphere-fill" id="user-fill"></div>
                        <div class="sphere-glow"></div>
                    </div>
                </div>
            </div>

            <div class="timer" id="meditation-timer">4</div>

            <div class="talking-warning" id="talking-warning"></div>
            <div class="feedback" id="feedback"></div>

            <button class="btn secondary" id="stop-meditation-btn" style="margin-top: 20px;">End Session</button>
        </div>

        <!-- Completion Screen -->
        <div class="screen" id="completion-screen">
            <h2>Session Complete!</h2>
            <p>Wonderful job on completing your breathing meditation.</p>

            <div class="completion-stats">
                <div class="stat-item">
                    <div class="stat-value" id="stat-rounds">5</div>
                    <div class="stat-label">Rounds Completed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-duration">0:00</div>
                    <div class="stat-label">Total Duration</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-sync">0%</div>
                    <div class="stat-label">Average Sync</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-breaths">0</div>
                    <div class="stat-label">Total Breaths</div>
                </div>
            </div>

            <button class="btn" id="restart-btn">Start Again</button>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            targetInhaleDuration: 4000,     // ms - target
            targetExhaleDuration: 4000,     // ms - target
            holdDuration: 1000,             // ms between phases
            totalRounds: 5,
            calibrationDuration: 6000,      // ms per calibration step
            adaptationRate: 0.5,            // How fast to adapt to target (0.5 = average)
            // Audio analysis settings
            fftSize: 2048,
            smoothingFactor: 0.3,           // For envelope smoothing
            featureHistoryLength: 30,       // ~500ms at 60fps
            // Breath detection weights (sum to 1.0)
            weights: {
                envelope: 0.35,             // Amplitude level
                envelopeSlope: 0.25,        // Rate of change (slow = breathing)
                spectralCentroid: 0.20,     // Frequency center (low = breathing)
                zeroCrossingRate: 0.20      // Stability (low = breathing)
            }
        };

        // ============================================
        // STATE
        // ============================================
        const state = {
            audioContext: null,
            analyser: null,
            microphone: null,
            frequencyData: null,
            timeData: null,
            isListening: false,

            // Audio features (current frame)
            features: {
                envelope: 0,                // Smoothed amplitude (0-1)
                envelopeSlope: 0,           // Rate of change (-1 to 1)
                spectralCentroid: 0,        // Hz - center frequency
                zeroCrossingRate: 0,        // Crossings per sample (0-0.5)
                breathScore: 0              // Combined score (0-1)
            },

            // Feature history for analysis
            featureHistory: [],

            // Calibration profiles
            calibration: {
                silence: {
                    envelope: 0,
                    spectralCentroid: 0,
                    zeroCrossingRate: 0
                },
                talking: {
                    envelope: 0,
                    spectralCentroid: 0,
                    zeroCrossingRate: 0,
                    envelopeSlopeVariance: 0
                },
                breathingIn: {
                    envelope: 0,
                    spectralCentroid: 0,
                    zeroCrossingRate: 0,
                    duration: 0,
                    envelopePattern: []      // Shape of breath
                },
                breathingOut: {
                    envelope: 0,
                    spectralCentroid: 0,
                    zeroCrossingRate: 0,
                    duration: 0,
                    envelopePattern: []
                }
            },

            // Breathing detection state
            breathPhase: 'idle',            // 'idle', 'rising', 'falling'
            breathStartTime: 0,
            lastBreathDuration: 0,
            breathConfidence: 0,            // How confident we are it's a breath

            // User sphere animation
            userSpherePercent: 0,
            userSphereTarget: 0,
            userAnimationStart: 0,
            userAnimationDuration: 4000,

            // Adaptive timing
            currentInhaleDuration: 4000,
            currentExhaleDuration: 4000,

            // Session state
            currentPhase: 'idle',
            currentRound: 0,
            meditationStartTime: 0,
            syncScores: [],
            totalBreaths: 0
        };

        // ============================================
        // AUDIO PROCESSING - IMPROVED
        // ============================================
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioContext.createAnalyser();
                state.analyser.fftSize = CONFIG.fftSize;
                state.analyser.smoothingTimeConstant = 0.5;

                state.microphone = state.audioContext.createMediaStreamSource(stream);
                state.microphone.connect(state.analyser);

                // Both frequency and time domain data
                state.frequencyData = new Uint8Array(state.analyser.frequencyBinCount);
                state.timeData = new Float32Array(state.analyser.fftSize);
                state.isListening = true;

                // Start audio monitoring loop
                monitorAudio();

                return true;
            } catch (error) {
                console.error('Audio init error:', error);
                return false;
            }
        }

        // Extract all audio features for current frame
        function extractFeatures() {
            if (!state.analyser || !state.isListening) {
                return state.features;
            }

            // Get both frequency and time domain data
            state.analyser.getByteFrequencyData(state.frequencyData);
            state.analyser.getFloatTimeDomainData(state.timeData);

            const sampleRate = state.audioContext.sampleRate;
            const prevEnvelope = state.features.envelope;

            // 1. ENVELOPE (RMS amplitude) - focus on breathing frequencies
            const binSize = sampleRate / CONFIG.fftSize;
            const lowBin = Math.floor(80 / binSize);   // 80 Hz
            const highBin = Math.floor(600 / binSize); // 600 Hz

            let sum = 0;
            let weightedSum = 0;
            let totalWeight = 0;

            for (let i = lowBin; i < highBin && i < state.frequencyData.length; i++) {
                const magnitude = state.frequencyData[i] / 255;
                sum += magnitude * magnitude;

                // For spectral centroid
                const freq = i * binSize;
                weightedSum += freq * magnitude;
                totalWeight += magnitude;
            }

            const rms = Math.sqrt(sum / (highBin - lowBin));

            // Smooth the envelope
            state.features.envelope = state.features.envelope * (1 - CONFIG.smoothingFactor) +
                                      rms * CONFIG.smoothingFactor;

            // 2. ENVELOPE SLOPE (rate of change)
            // Breathing has slow, gradual changes; speech is rapid
            const rawSlope = state.features.envelope - prevEnvelope;
            state.features.envelopeSlope = rawSlope;

            // 3. SPECTRAL CENTROID (center of mass of spectrum)
            // Breathing is lower frequency, speech is higher
            state.features.spectralCentroid = totalWeight > 0 ? weightedSum / totalWeight : 0;

            // 4. ZERO CROSSING RATE (from time domain)
            // Breathing has fewer zero crossings than speech
            let zeroCrossings = 0;
            for (let i = 1; i < state.timeData.length; i++) {
                if ((state.timeData[i] >= 0 && state.timeData[i - 1] < 0) ||
                    (state.timeData[i] < 0 && state.timeData[i - 1] >= 0)) {
                    zeroCrossings++;
                }
            }
            state.features.zeroCrossingRate = zeroCrossings / state.timeData.length;

            // Store in history
            state.featureHistory.push({
                envelope: state.features.envelope,
                envelopeSlope: state.features.envelopeSlope,
                spectralCentroid: state.features.spectralCentroid,
                zeroCrossingRate: state.features.zeroCrossingRate,
                timestamp: Date.now()
            });

            if (state.featureHistory.length > CONFIG.featureHistoryLength) {
                state.featureHistory.shift();
            }

            // 5. Calculate BREATH SCORE
            state.features.breathScore = calculateBreathScore();

            return state.features;
        }

        // Calculate how likely current audio is breathing (0-1)
        function calculateBreathScore() {
            const cal = state.calibration;
            const f = state.features;

            // Need calibration data
            if (cal.silence.envelope === 0) return 0;

            let score = 0;

            // 1. Envelope score: above silence, below talking
            const envelopeAboveSilence = f.envelope > cal.silence.envelope * 1.3;
            const envelopeBelowTalking = f.envelope < cal.talking.envelope * 0.8;
            const envelopeInBreathRange = envelopeAboveSilence && envelopeBelowTalking;

            if (envelopeInBreathRange) {
                // Normalize to 0-1 within breathing range
                const breathEnv = Math.max(cal.breathingIn.envelope, cal.breathingOut.envelope);
                const normalizedEnv = Math.min(1, f.envelope / (breathEnv + 0.01));
                score += CONFIG.weights.envelope * normalizedEnv;
            }

            // 2. Envelope slope score: breathing changes slowly
            const slopeVariance = getRecentSlopeVariance();
            const talkingSlopeVar = cal.talking.envelopeSlopeVariance || 0.01;
            const slopeScore = Math.max(0, 1 - (slopeVariance / talkingSlopeVar));
            score += CONFIG.weights.envelopeSlope * slopeScore;

            // 3. Spectral centroid score: breathing is low frequency
            const breathCentroid = Math.max(cal.breathingIn.spectralCentroid, cal.breathingOut.spectralCentroid) || 300;
            const talkingCentroid = cal.talking.spectralCentroid || 500;

            if (f.spectralCentroid > 0 && f.spectralCentroid < talkingCentroid) {
                const centroidScore = 1 - (f.spectralCentroid / talkingCentroid);
                score += CONFIG.weights.spectralCentroid * Math.max(0, centroidScore);
            }

            // 4. Zero crossing rate score: breathing has fewer crossings
            const breathZCR = Math.max(cal.breathingIn.zeroCrossingRate, cal.breathingOut.zeroCrossingRate) || 0.05;
            const talkingZCR = cal.talking.zeroCrossingRate || 0.15;

            if (f.zeroCrossingRate < talkingZCR) {
                const zcrScore = 1 - (f.zeroCrossingRate / talkingZCR);
                score += CONFIG.weights.zeroCrossingRate * Math.max(0, zcrScore);
            }

            return Math.max(0, Math.min(1, score));
        }

        // Get variance of recent envelope slopes
        function getRecentSlopeVariance() {
            if (state.featureHistory.length < 5) return 0;

            const slopes = state.featureHistory.slice(-10).map(f => f.envelopeSlope);
            const avg = slopes.reduce((a, b) => a + b, 0) / slopes.length;
            return slopes.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / slopes.length;
        }

        // Detect if user is talking (not breathing)
        function isTalkingDetected() {
            const f = state.features;
            const cal = state.calibration;

            if (cal.talking.envelope === 0) return false;

            // High envelope + high spectral centroid + high ZCR = talking
            const highEnvelope = f.envelope > cal.talking.envelope * 0.6;
            const highCentroid = f.spectralCentroid > cal.talking.spectralCentroid * 0.7;
            const highZCR = f.zeroCrossingRate > cal.talking.zeroCrossingRate * 0.6;
            const highSlopeVariance = getRecentSlopeVariance() > (cal.talking.envelopeSlopeVariance || 0.005) * 0.5;

            // Need multiple indicators to confirm talking
            const talkingIndicators = [highEnvelope, highCentroid, highZCR, highSlopeVariance];
            const talkingCount = talkingIndicators.filter(Boolean).length;

            return talkingCount >= 3;
        }

        // Detect breath phase transitions
        function detectBreathPhase() {
            const f = state.features;
            const cal = state.calibration;
            const prevPhase = state.breathPhase;

            const silenceThreshold = cal.silence.envelope * 1.5;
            const isActive = f.envelope > silenceThreshold;
            const isRising = f.envelopeSlope > 0.002;
            const isFalling = f.envelopeSlope < -0.002;

            // State machine for breath detection
            if (!isActive) {
                if (prevPhase === 'falling') {
                    // Breath just ended
                    state.lastBreathDuration = Date.now() - state.breathStartTime;
                }
                state.breathPhase = 'idle';
            } else if (isRising && prevPhase !== 'rising') {
                state.breathPhase = 'rising';
                if (prevPhase === 'idle') {
                    state.breathStartTime = Date.now();
                }
            } else if (isFalling && prevPhase === 'rising') {
                state.breathPhase = 'falling';
            }

            // Calculate confidence based on breath score
            state.breathConfidence = f.breathScore;

            return state.breathPhase;
        }

        function monitorAudio() {
            if (!state.isListening) return;

            extractFeatures();
            detectBreathPhase();
            updateAudioLevelDisplay();

            requestAnimationFrame(monitorAudio);
        }

        function updateAudioLevelDisplay() {
            const fill = document.getElementById('audio-level-fill');
            if (fill) {
                // Show breath score instead of just level
                const displayValue = state.features.breathScore * 100;
                fill.style.width = `${Math.min(displayValue, 100)}%`;

                // Color based on confidence
                if (state.features.breathScore > 0.6) {
                    fill.style.background = 'linear-gradient(90deg, #4f8, #8f4)';
                } else if (state.features.breathScore > 0.3) {
                    fill.style.background = 'linear-gradient(90deg, #ff8, #fa4)';
                } else {
                    fill.style.background = 'linear-gradient(90deg, #888, #666)';
                }
            }

            // Update debug panel
            updateDebugPanel();
        }

        function updateDebugPanel() {
            const panel = document.getElementById('debug-panel');
            if (!panel || panel.style.display === 'none') return;

            const f = state.features;

            document.getElementById('debug-envelope').textContent = f.envelope.toFixed(3);
            document.getElementById('debug-envelope-bar').style.width = `${Math.min(f.envelope * 500, 100)}%`;

            const slopeEl = document.getElementById('debug-slope');
            slopeEl.textContent = f.envelopeSlope.toFixed(4);
            slopeEl.className = 'debug-value' + (Math.abs(f.envelopeSlope) > 0.005 ? ' warning' : '');

            document.getElementById('debug-centroid').textContent = `${f.spectralCentroid.toFixed(0)} Hz`;
            document.getElementById('debug-zcr').textContent = f.zeroCrossingRate.toFixed(3);

            const scoreEl = document.getElementById('debug-breath-score');
            scoreEl.textContent = `${(f.breathScore * 100).toFixed(0)}%`;
            scoreEl.className = 'debug-value' + (f.breathScore > 0.5 ? ' good' : '');
            document.getElementById('debug-score-bar').style.width = `${f.breathScore * 100}%`;

            document.getElementById('debug-phase').textContent = state.breathPhase;

            const talkingEl = document.getElementById('debug-talking');
            const talking = isTalkingDetected();
            talkingEl.textContent = talking ? 'YES' : 'No';
            talkingEl.className = 'debug-value' + (talking ? ' warning' : ' good');
        }

        // Toggle debug panel with 'D' key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                const panel = document.getElementById('debug-panel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        });

        // ============================================
        // TEXT TO SPEECH
        // ============================================
        function speak(text, callback) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.85;
                utterance.pitch = 1;
                utterance.volume = 0.8;

                // Try to find a calm, clear voice
                const voices = window.speechSynthesis.getVoices();
                const preferredVoice = voices.find(v =>
                    v.name.includes('Google') ||
                    v.name.includes('Samantha') ||
                    v.name.includes('Daniel')
                );
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }

                if (callback) {
                    utterance.onend = callback;
                }

                window.speechSynthesis.speak(utterance);
            } else {
                // Fallback: just call callback after estimated time
                if (callback) {
                    setTimeout(callback, text.length * 80);
                }
            }
        }

        // ============================================
        // CALIBRATION - IMPROVED
        // ============================================
        async function runCalibration() {
            // Step 1: Silence
            await calibrateSilence();

            // Step 2: Talking
            await calibrateTalking();

            // Step 3: Breathing In
            await calibrateBreathingIn();

            // Step 4: Breathing Out
            await calibrateBreathingOut();

            // Show results and ready screen
            showCalibrationResults();
            showScreen('ready-screen');
        }

        // Collect feature samples over a duration
        function collectFeatureSamples(durationMs) {
            return new Promise((resolve) => {
                const samples = [];
                const startTime = Date.now();

                const collect = () => {
                    if (Date.now() - startTime < durationMs) {
                        extractFeatures();
                        samples.push({
                            envelope: state.features.envelope,
                            spectralCentroid: state.features.spectralCentroid,
                            zeroCrossingRate: state.features.zeroCrossingRate,
                            envelopeSlope: state.features.envelopeSlope
                        });
                        setTimeout(collect, 50);
                    } else {
                        resolve(samples);
                    }
                };

                collect();
            });
        }

        // Calculate average features from samples
        function averageFeatures(samples) {
            if (samples.length === 0) return { envelope: 0, spectralCentroid: 0, zeroCrossingRate: 0 };

            const sum = samples.reduce((acc, s) => ({
                envelope: acc.envelope + s.envelope,
                spectralCentroid: acc.spectralCentroid + s.spectralCentroid,
                zeroCrossingRate: acc.zeroCrossingRate + s.zeroCrossingRate
            }), { envelope: 0, spectralCentroid: 0, zeroCrossingRate: 0 });

            return {
                envelope: sum.envelope / samples.length,
                spectralCentroid: sum.spectralCentroid / samples.length,
                zeroCrossingRate: sum.zeroCrossingRate / samples.length
            };
        }

        function calibrateSilence() {
            return new Promise((resolve) => {
                document.getElementById('cal-silence-dot').classList.add('active');
                updateCalibrationProgress(1, 4);

                speak("Let's start by calibrating silence. Please remain quiet and still for a few seconds.", async () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Stay quiet and still...";

                    await new Promise(r => setTimeout(r, 500));
                    const samples = await collectFeatureSamples(CONFIG.calibrationDuration);

                    state.calibration.silence = averageFeatures(samples);

                    document.getElementById('cal-silence-dot').classList.remove('active');
                    document.getElementById('cal-silence-dot').classList.add('complete');

                    console.log('Silence calibration:', state.calibration.silence);
                    speak("Good. Silence calibrated.", resolve);
                });
            });
        }

        function calibrateTalking() {
            return new Promise((resolve) => {
                document.getElementById('cal-talking-dot').classList.add('active');
                updateCalibrationProgress(2, 4);

                speak("Now, please speak normally for a few seconds. Count from one to ten, or say anything you like.", async () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Please speak now... (count 1 to 10)";

                    await new Promise(r => setTimeout(r, 500));
                    const samples = await collectFeatureSamples(CONFIG.calibrationDuration);

                    const avg = averageFeatures(samples);

                    // Also calculate envelope slope variance (speech has high variance)
                    const slopes = samples.map(s => s.envelopeSlope);
                    const slopeAvg = slopes.reduce((a, b) => a + b, 0) / slopes.length;
                    const slopeVariance = slopes.reduce((a, b) => a + Math.pow(b - slopeAvg, 2), 0) / slopes.length;

                    state.calibration.talking = {
                        ...avg,
                        envelopeSlopeVariance: slopeVariance
                    };

                    document.getElementById('cal-talking-dot').classList.remove('active');
                    document.getElementById('cal-talking-dot').classList.add('complete');

                    console.log('Talking calibration:', state.calibration.talking);
                    speak("Thank you. Now let's measure your breathing.", resolve);
                });
            });
        }

        function calibrateBreathingIn() {
            return new Promise((resolve) => {
                document.getElementById('cal-breathin-dot').classList.add('active');
                updateCalibrationProgress(3, 4);

                speak("Take a slow, deep breath in through your nose. Start when you're ready and breathe in completely.", () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Breathe IN slowly... (we're measuring)";

                    let breathStarted = false;
                    let breathStartTime = 0;
                    let peakEnvelope = 0;
                    const featureSamples = [];
                    const envelopePattern = [];
                    const startTime = Date.now();
                    const maxWaitTime = 12000;

                    const silenceEnv = state.calibration.silence.envelope;
                    const threshold = silenceEnv * 1.5;

                    const monitor = () => {
                        extractFeatures();
                        const f = state.features;

                        // Update sphere visualization
                        const displayLevel = Math.min(1, f.envelope / (state.calibration.talking.envelope + 0.01));
                        setSpherePercent('calibration-fill', displayLevel * 100);

                        if (!breathStarted && f.envelope > threshold) {
                            breathStarted = true;
                            breathStartTime = Date.now();
                        }

                        if (breathStarted) {
                            featureSamples.push({
                                envelope: f.envelope,
                                spectralCentroid: f.spectralCentroid,
                                zeroCrossingRate: f.zeroCrossingRate
                            });
                            envelopePattern.push(f.envelope);

                            if (f.envelope > peakEnvelope) {
                                peakEnvelope = f.envelope;
                            }

                            // Breath ended when level drops significantly
                            const timeSinceStart = Date.now() - breathStartTime;
                            if (f.envelope < peakEnvelope * 0.35 && timeSinceStart > 1000) {
                                const duration = Date.now() - breathStartTime;
                                const avg = averageFeatures(featureSamples);

                                state.calibration.breathingIn = {
                                    ...avg,
                                    duration: duration,
                                    envelopePattern: envelopePattern
                                };

                                document.getElementById('timing-info').textContent =
                                    `Inhale: ${(duration / 1000).toFixed(1)}s | Centroid: ${avg.spectralCentroid.toFixed(0)}Hz`;

                                document.getElementById('cal-breathin-dot').classList.remove('active');
                                document.getElementById('cal-breathin-dot').classList.add('complete');

                                console.log('Breathing In calibration:', state.calibration.breathingIn);
                                speak(`Good. Your inhale was ${(duration / 1000).toFixed(1)} seconds.`, resolve);
                                return;
                            }
                        }

                        if (Date.now() - startTime < maxWaitTime) {
                            setTimeout(monitor, 50);
                        } else {
                            // Timeout - use defaults
                            state.calibration.breathingIn = {
                                envelope: peakEnvelope || 0.1,
                                spectralCentroid: 250,
                                zeroCrossingRate: 0.05,
                                duration: 4000,
                                envelopePattern: []
                            };
                            document.getElementById('cal-breathin-dot').classList.remove('active');
                            document.getElementById('cal-breathin-dot').classList.add('complete');
                            speak("Using default timing. Let's continue.", resolve);
                        }
                    };

                    setTimeout(monitor, 500);
                });
            });
        }

        function calibrateBreathingOut() {
            return new Promise((resolve) => {
                document.getElementById('cal-breathout-dot').classList.add('active');
                updateCalibrationProgress(4, 4);

                setSpherePercent('calibration-fill', 100);

                speak("Now slowly breathe out through your mouth. Start when you're ready.", () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Breathe OUT slowly... (we're measuring)";

                    let breathStarted = false;
                    let breathStartTime = 0;
                    let peakEnvelope = 0;
                    const featureSamples = [];
                    const envelopePattern = [];
                    const startTime = Date.now();
                    const maxWaitTime = 12000;

                    const silenceEnv = state.calibration.silence.envelope;
                    const threshold = silenceEnv * 1.5;

                    const monitor = () => {
                        extractFeatures();
                        const f = state.features;

                        // Update sphere - goes from 100 to 0 based on time since breath started
                        if (breathStarted) {
                            const elapsed = Date.now() - breathStartTime;
                            const estimatedDuration = state.calibration.breathingIn.duration || 4000;
                            const percent = Math.max(0, 100 - (elapsed / estimatedDuration) * 100);
                            setSpherePercent('calibration-fill', percent);
                        }

                        if (!breathStarted && f.envelope > threshold) {
                            breathStarted = true;
                            breathStartTime = Date.now();
                        }

                        if (breathStarted) {
                            featureSamples.push({
                                envelope: f.envelope,
                                spectralCentroid: f.spectralCentroid,
                                zeroCrossingRate: f.zeroCrossingRate
                            });
                            envelopePattern.push(f.envelope);

                            if (f.envelope > peakEnvelope) {
                                peakEnvelope = f.envelope;
                            }

                            // Check if breath ended
                            const timeSinceStart = Date.now() - breathStartTime;
                            if (f.envelope < peakEnvelope * 0.3 && timeSinceStart > 1000) {
                                const duration = Date.now() - breathStartTime;
                                const avg = averageFeatures(featureSamples);

                                state.calibration.breathingOut = {
                                    ...avg,
                                    duration: duration,
                                    envelopePattern: envelopePattern
                                };

                                setSpherePercent('calibration-fill', 0);

                                document.getElementById('timing-info').textContent =
                                    `Exhale: ${(duration / 1000).toFixed(1)}s | Centroid: ${avg.spectralCentroid.toFixed(0)}Hz`;

                                document.getElementById('cal-breathout-dot').classList.remove('active');
                                document.getElementById('cal-breathout-dot').classList.add('complete');

                                console.log('Breathing Out calibration:', state.calibration.breathingOut);
                                speak(`Your exhale was ${(duration / 1000).toFixed(1)} seconds. Calibration complete.`, resolve);
                                return;
                            }
                        }

                        if (Date.now() - startTime < maxWaitTime) {
                            setTimeout(monitor, 50);
                        } else {
                            state.calibration.breathingOut = {
                                envelope: peakEnvelope || 0.1,
                                spectralCentroid: 200,
                                zeroCrossingRate: 0.05,
                                duration: 4000,
                                envelopePattern: []
                            };
                            document.getElementById('cal-breathout-dot').classList.remove('active');
                            document.getElementById('cal-breathout-dot').classList.add('complete');
                            speak("Using default timing. Calibration complete.", resolve);
                        }
                    };

                    setTimeout(monitor, 500);
                });
            });
        }

        function showCalibrationResults() {
            const measuredIn = state.calibration.breathingIn.duration / 1000;
            const measuredOut = state.calibration.breathingOut.duration / 1000;
            const targetIn = CONFIG.targetInhaleDuration / 1000;
            const targetOut = CONFIG.targetExhaleDuration / 1000;

            document.getElementById('result-inhale').textContent = `${measuredIn.toFixed(1)}s`;
            document.getElementById('result-exhale').textContent = `${measuredOut.toFixed(1)}s`;
            document.getElementById('result-target-in').textContent = `${targetIn.toFixed(1)}s`;
            document.getElementById('result-target-out').textContent = `${targetOut.toFixed(1)}s`;

            // Calculate initial adaptive durations
            state.currentInhaleDuration = (state.calibration.breathingIn.duration + CONFIG.targetInhaleDuration) / 2;
            state.currentExhaleDuration = (state.calibration.breathingOut.duration + CONFIG.targetExhaleDuration) / 2;

            // Generate adjustment hint
            let hint = '';
            const inDiff = targetIn - measuredIn;
            const outDiff = targetOut - measuredOut;

            if (Math.abs(inDiff) < 0.5 && Math.abs(outDiff) < 0.5) {
                hint = "Your breathing pace is close to the target. Great!";
            } else {
                const parts = [];
                if (inDiff > 0.5) {
                    parts.push(`breathe in ${inDiff.toFixed(1)}s slower`);
                } else if (inDiff < -0.5) {
                    parts.push(`breathe in ${Math.abs(inDiff).toFixed(1)}s faster`);
                }
                if (outDiff > 0.5) {
                    parts.push(`breathe out ${outDiff.toFixed(1)}s slower`);
                } else if (outDiff < -0.5) {
                    parts.push(`breathe out ${Math.abs(outDiff).toFixed(1)}s faster`);
                }
                hint = `To match the target, try to ${parts.join(' and ')}.`;
            }

            document.getElementById('adjustment-hint').textContent = hint;

            // Speak the adjustment hint
            speak(hint);
        }

        function updateCalibrationProgress(step, total) {
            const progress = (step / total) * 100;
            document.getElementById('calibration-progress').style.width = `${progress}%`;
            document.getElementById('calibration-progress-text').textContent = `Step ${step} of ${total}`;
        }

        // ============================================
        // SPHERE ANIMATION
        // ============================================
        function setSpherePercent(fillId, percent) {
            const fill = document.getElementById(fillId);
            if (!fill) return;

            percent = Math.max(0, Math.min(100, percent));
            fill.style.height = `${percent}%`;

            if (percent > 90) {
                fill.style.borderRadius = '90px';
            } else {
                fill.style.borderRadius = '0 0 90px 90px';
            }
        }

        function animateSphere(fillId, fromPercent, toPercent, duration, callback) {
            const fill = document.getElementById(fillId);
            if (!fill) return;

            const startTime = Date.now();
            const startPercent = fromPercent;
            const endPercent = toPercent;

            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const currentPercent = startPercent + (endPercent - startPercent) * eased;
                setSpherePercent(fillId, currentPercent);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            };

            animate();
        }

        // User sphere animation based on detected breathing
        function startUserSphereAnimation(fromPercent, toPercent, duration) {
            state.userSpherePercent = fromPercent;
            state.userSphereTarget = toPercent;
            state.userAnimationStart = Date.now();
            state.userAnimationDuration = duration;
        }

        function updateUserSphereFromBreathing() {
            const elapsed = Date.now() - state.userAnimationStart;
            const progress = Math.min(elapsed / state.userAnimationDuration, 1);

            // Ease in-out
            const eased = progress < 0.5
                ? 2 * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            const currentPercent = state.userSpherePercent +
                (state.userSphereTarget - state.userSpherePercent) * eased;

            setSpherePercent('user-fill', currentPercent);

            return progress;
        }

        // ============================================
        // MEDITATION SESSION
        // ============================================
        async function startMeditation() {
            state.currentRound = 0;
            state.syncScores = [];
            state.totalBreaths = 0;
            state.meditationStartTime = Date.now();

            // Reset user sphere
            setSpherePercent('user-fill', 0);
            setSpherePercent('guide-fill', 0);

            showScreen('meditation-screen');
            document.getElementById('talking-warning').textContent = '';

            speak("Let's begin. Find a comfortable position and relax.", () => {
                setTimeout(() => runMeditationRound(), 2000);
            });
        }

        async function runMeditationRound() {
            state.currentRound++;

            if (state.currentRound > CONFIG.totalRounds) {
                endMeditation();
                return;
            }

            document.getElementById('round-counter').textContent =
                `Round ${state.currentRound} of ${CONFIG.totalRounds}`;
            document.getElementById('talking-warning').textContent = '';

            // Breathe In
            await breatheIn();

            // Brief hold
            await hold();

            // Breathe Out
            await breatheOut();

            // Brief hold
            await hold();

            state.totalBreaths++;

            // Adapt timing towards target for next round
            state.currentInhaleDuration = state.currentInhaleDuration +
                (CONFIG.targetInhaleDuration - state.currentInhaleDuration) * CONFIG.adaptationRate;
            state.currentExhaleDuration = state.currentExhaleDuration +
                (CONFIG.targetExhaleDuration - state.currentExhaleDuration) * CONFIG.adaptationRate;

            // Continue to next round
            setTimeout(() => runMeditationRound(), 500);
        }

        function breatheIn() {
            return new Promise((resolve) => {
                state.currentPhase = 'in';
                document.getElementById('breathing-phase').textContent = 'Breathe In...';

                speak("Breathe in");

                const duration = CONFIG.targetInhaleDuration;
                const userDuration = state.currentInhaleDuration;

                // Animate guide sphere (always at target pace)
                animateSphere('guide-fill', 0, 100, duration);

                // Start user sphere animation (at adaptive pace)
                startUserSphereAnimation(0, 100, userDuration);

                const syncSamples = [];
                const startTime = Date.now();
                let talkingDetectedThisPhase = false;

                const countdownInterval = setInterval(() => {
                    const remaining = Math.ceil((duration - (Date.now() - startTime)) / 1000);
                    document.getElementById('meditation-timer').textContent = Math.max(0, remaining);
                }, 100);

                const monitor = () => {
                    if (Date.now() - startTime < duration) {
                        getAudioLevel(); // Update audio state

                        // Check for talking
                        if (isTalkingDetected()) {
                            document.getElementById('talking-warning').textContent =
                                'Talking detected - please concentrate on breathing';
                            talkingDetectedThisPhase = true;
                        } else if (!talkingDetectedThisPhase) {
                            document.getElementById('talking-warning').textContent = '';
                        }

                        // Update user sphere based on time (smooth animation)
                        const userProgress = updateUserSphereFromBreathing();

                        // Calculate guide progress for sync scoring
                        const guideProgress = (Date.now() - startTime) / duration;
                        syncSamples.push(Math.abs(userProgress - guideProgress));

                        setTimeout(monitor, 50);
                    } else {
                        clearInterval(countdownInterval);

                        // Ensure spheres are at 100%
                        setSpherePercent('user-fill', 100);

                        // Calculate sync score
                        const avgDiff = syncSamples.reduce((a, b) => a + b, 0) / syncSamples.length;
                        const syncScore = Math.max(0, 100 - avgDiff * 200);
                        state.syncScores.push(syncScore);

                        updateFeedback(syncScore);
                        resolve();
                    }
                };

                monitor();
            });
        }

        function breatheOut() {
            return new Promise((resolve) => {
                state.currentPhase = 'out';
                document.getElementById('breathing-phase').textContent = 'Breathe Out...';

                speak("Breathe out");

                const duration = CONFIG.targetExhaleDuration;
                const userDuration = state.currentExhaleDuration;

                // Animate guide sphere (always at target pace)
                animateSphere('guide-fill', 100, 0, duration);

                // Start user sphere animation (at adaptive pace, going from 100 to 0)
                startUserSphereAnimation(100, 0, userDuration);

                const syncSamples = [];
                const startTime = Date.now();
                let talkingDetectedThisPhase = false;

                const countdownInterval = setInterval(() => {
                    const remaining = Math.ceil((duration - (Date.now() - startTime)) / 1000);
                    document.getElementById('meditation-timer').textContent = Math.max(0, remaining);
                }, 100);

                const monitor = () => {
                    if (Date.now() - startTime < duration) {
                        getAudioLevel();

                        // Check for talking
                        if (isTalkingDetected()) {
                            document.getElementById('talking-warning').textContent =
                                'Talking detected - please concentrate on breathing';
                            talkingDetectedThisPhase = true;
                        } else if (!talkingDetectedThisPhase) {
                            document.getElementById('talking-warning').textContent = '';
                        }

                        // Update user sphere (smooth animation from 100 to 0)
                        updateUserSphereFromBreathing();

                        // For sync scoring
                        const userProgress = (Date.now() - state.userAnimationStart) / state.userAnimationDuration;
                        const guideProgress = (Date.now() - startTime) / duration;
                        syncSamples.push(Math.abs(userProgress - guideProgress));

                        setTimeout(monitor, 50);
                    } else {
                        clearInterval(countdownInterval);

                        // Ensure spheres are at 0%
                        setSpherePercent('user-fill', 0);

                        const avgDiff = syncSamples.reduce((a, b) => a + b, 0) / syncSamples.length;
                        const syncScore = Math.max(0, 100 - avgDiff * 200);
                        state.syncScores.push(syncScore);

                        updateFeedback(syncScore);
                        resolve();
                    }
                };

                monitor();
            });
        }

        function hold() {
            return new Promise((resolve) => {
                state.currentPhase = 'hold';
                document.getElementById('breathing-phase').textContent = 'Hold...';
                document.getElementById('meditation-timer').textContent = '...';
                document.getElementById('talking-warning').textContent = '';
                setTimeout(resolve, CONFIG.holdDuration);
            });
        }

        function updateFeedback(score) {
            const feedback = document.getElementById('feedback');
            if (score > 80) {
                feedback.textContent = 'Excellent! Keep it up!';
                feedback.style.color = '#8f8';
            } else if (score > 60) {
                feedback.textContent = 'Good rhythm!';
                feedback.style.color = '#afc';
            } else if (score > 40) {
                feedback.textContent = 'Try to match the guide';
                feedback.style.color = '#ffa';
            } else {
                feedback.textContent = 'Follow the blue sphere';
                feedback.style.color = '#faa';
            }
        }

        function endMeditation() {
            const duration = Math.floor((Date.now() - state.meditationStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;

            const avgSync = state.syncScores.length > 0
                ? Math.round(state.syncScores.reduce((a, b) => a + b, 0) / state.syncScores.length)
                : 0;

            document.getElementById('stat-rounds').textContent = state.currentRound - 1;
            document.getElementById('stat-duration').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('stat-sync').textContent = `${avgSync}%`;
            document.getElementById('stat-breaths').textContent = state.totalBreaths;

            speak("Wonderful. You've completed your meditation session. Take a moment to notice how you feel.");

            showScreen('completion-screen');
        }

        // ============================================
        // SCREEN NAVIGATION
        // ============================================
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        // ============================================
        // STAR FIELD
        // ============================================
        function createStarfield() {
            const container = document.getElementById('stars');
            const starCount = 150;

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.width = `${Math.random() * 3 + 1}px`;
                star.style.height = star.style.width;
                star.style.animationDelay = `${Math.random() * 3}s`;
                container.appendChild(star);
            }
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        document.getElementById('start-btn').addEventListener('click', () => {
            showScreen('permission-screen');
        });

        document.getElementById('permission-btn').addEventListener('click', async () => {
            const btn = document.getElementById('permission-btn');
            btn.disabled = true;
            btn.textContent = 'Requesting access...';

            const success = await initAudio();

            if (success) {
                showScreen('calibration-screen');
                // Wait for voices to load
                setTimeout(() => runCalibration(), 1000);
            } else {
                document.getElementById('permission-error').style.display = 'block';
                document.getElementById('permission-error').textContent =
                    'Could not access microphone. Please allow microphone access and try again.';
                btn.disabled = false;
                btn.textContent = 'Try Again';
            }
        });

        document.getElementById('begin-meditation-btn').addEventListener('click', () => {
            startMeditation();
        });

        document.getElementById('stop-meditation-btn').addEventListener('click', () => {
            state.currentRound = CONFIG.totalRounds + 1;
            endMeditation();
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            // Reset adaptive timing
            state.currentInhaleDuration = (state.calibration.breathingIn.duration + CONFIG.targetInhaleDuration) / 2;
            state.currentExhaleDuration = (state.calibration.breathingOut.duration + CONFIG.targetExhaleDuration) / 2;
            showScreen('ready-screen');
        });

        // Load voices
        if ('speechSynthesis' in window) {
            window.speechSynthesis.getVoices();
            window.speechSynthesis.onvoiceschanged = () => {
                window.speechSynthesis.getVoices();
            };
        }

        // Initialize
        createStarfield();
    </script>
</body>
</html>
