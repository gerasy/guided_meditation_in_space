<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guided Meditation - Breathing in Space</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }

        /* Starfield background */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Main container */
        .container {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* Screens */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            max-width: 800px;
            width: 100%;
        }

        .screen.active {
            display: flex;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(100, 150, 255, 0.5);
        }

        h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #8af;
        }

        p {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #cce;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(135deg, #4a6cf7 0%, #6a4cf7 100%);
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 30px rgba(100, 100, 255, 0.4);
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 40px rgba(100, 100, 255, 0.6);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: linear-gradient(135deg, #3a4c87 0%, #4a3c87 100%);
        }

        /* Sphere container */
        .spheres-container {
            display: flex;
            gap: 80px;
            margin: 40px 0;
            align-items: center;
            justify-content: center;
        }

        .sphere-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .sphere-label {
            font-size: 1rem;
            color: #8af;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Sphere styling */
        .sphere {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at 30% 30%, #1a2a5a, #0a1030);
            box-shadow:
                0 0 60px rgba(100, 150, 255, 0.3),
                inset 0 0 60px rgba(50, 100, 200, 0.2);
            transition: transform 0.1s ease-out;
        }

        .sphere-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top,
                rgba(100, 200, 255, 0.8) 0%,
                rgba(150, 200, 255, 0.6) 50%,
                rgba(200, 220, 255, 0.4) 100%);
            transition: height 0.15s ease-out;
            border-radius: 0 0 90px 90px;
        }

        .sphere-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom,
                rgba(255, 255, 255, 0.4),
                transparent);
            border-radius: 50%;
            transform: translateY(-50%);
        }

        .sphere-glow {
            position: absolute;
            top: 10%;
            left: 15%;
            width: 30%;
            height: 30%;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            border-radius: 50%;
        }

        /* Guide sphere specific */
        .sphere.guide {
            border: 3px solid rgba(100, 200, 255, 0.5);
        }

        /* User sphere specific */
        .sphere.user {
            border: 3px solid rgba(150, 255, 150, 0.5);
        }

        .sphere.user .sphere-fill {
            background: linear-gradient(to top,
                rgba(100, 255, 150, 0.8) 0%,
                rgba(150, 255, 180, 0.6) 50%,
                rgba(200, 255, 220, 0.4) 100%);
        }

        /* Single sphere for calibration */
        .single-sphere {
            width: 200px;
            height: 200px;
        }

        /* Progress indicator */
        .progress-container {
            width: 100%;
            max-width: 400px;
            margin: 20px 0;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a6cf7, #8af);
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #aac;
        }

        /* Audio level indicator */
        .audio-level {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .audio-level-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f8, #8f4);
            transition: width 0.05s ease-out;
            width: 0%;
        }

        /* Instructions display */
        .instruction {
            font-size: 1.5rem;
            color: #fff;
            margin: 20px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
        }

        /* Calibration status */
        .calibration-status {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .calibration-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
        }

        .calibration-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #555;
        }

        .calibration-dot.complete {
            background: #4f8;
            box-shadow: 0 0 10px #4f8;
        }

        .calibration-dot.active {
            background: #ff8;
            box-shadow: 0 0 10px #ff8;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        /* Timer display */
        .timer {
            font-size: 3rem;
            font-weight: 300;
            color: #8af;
            margin: 10px 0;
        }

        /* Breathing phase indicator */
        .breathing-phase {
            font-size: 2rem;
            color: #8af;
            margin: 20px 0;
            min-height: 50px;
        }

        /* Score/feedback */
        .feedback {
            font-size: 1.2rem;
            color: #afc;
            margin: 10px 0;
            min-height: 30px;
        }

        /* Talking warning */
        .talking-warning {
            font-size: 1.1rem;
            color: #f66;
            margin: 5px 0;
            min-height: 25px;
            font-weight: bold;
        }

        /* Settings panel */
        .settings {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        .settings-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 10px 15px;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.2rem;
        }

        /* Round counter */
        .round-counter {
            font-size: 1rem;
            color: #8af;
            margin-bottom: 10px;
        }

        /* Timing info */
        .timing-info {
            font-size: 0.9rem;
            color: #aac;
            margin: 10px 0;
        }

        /* Completion screen */
        .completion-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
        }

        .stat-value {
            font-size: 2rem;
            color: #8af;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #aac;
            margin-top: 5px;
        }

        /* Calibration results */
        .calibration-results {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            max-width: 500px;
        }

        .calibration-results h3 {
            color: #8af;
            margin-bottom: 15px;
        }

        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .result-row:last-child {
            border-bottom: none;
        }

        .result-label {
            color: #aac;
        }

        .result-value {
            color: #fff;
            font-weight: bold;
        }

        .adjustment-hint {
            margin-top: 15px;
            padding: 10px;
            background: rgba(100, 150, 255, 0.1);
            border-radius: 10px;
            font-size: 0.95rem;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>

    <div class="container">
        <!-- Welcome Screen -->
        <div class="screen active" id="welcome-screen">
            <h1>Breathing in Space</h1>
            <p>Welcome to your guided meditation journey through the cosmos.<br>
            We'll practice breathing exercises together, with visual guidance to help you sync your breath.</p>
            <p>This experience uses your microphone to detect your breathing patterns.<br>
            First, we'll calibrate the system to your unique breathing.</p>
            <button class="btn" id="start-btn">Begin Journey</button>
        </div>

        <!-- Microphone Permission Screen -->
        <div class="screen" id="permission-screen">
            <h2>Microphone Access</h2>
            <p>To detect your breathing, we need access to your microphone.<br>
            Your audio is processed locally and never leaves your device.</p>
            <button class="btn" id="permission-btn">Allow Microphone</button>
            <p id="permission-error" style="color: #f88; display: none;"></p>
        </div>

        <!-- Calibration Screen -->
        <div class="screen" id="calibration-screen">
            <h2>Calibration Setup</h2>

            <div class="calibration-status">
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-silence-dot"></div>
                    <span>Silence</span>
                </div>
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-talking-dot"></div>
                    <span>Talking</span>
                </div>
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-breathin-dot"></div>
                    <span>Breathe In</span>
                </div>
                <div class="calibration-item">
                    <div class="calibration-dot" id="cal-breathout-dot"></div>
                    <span>Breathe Out</span>
                </div>
            </div>

            <div class="instruction" id="calibration-instruction">
                Preparing calibration...
            </div>

            <div class="sphere single-sphere" id="calibration-sphere">
                <div class="sphere-fill" id="calibration-fill"></div>
                <div class="sphere-glow"></div>
            </div>

            <div class="audio-level">
                <div class="audio-level-fill" id="audio-level-fill"></div>
            </div>

            <div class="timing-info" id="timing-info"></div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="calibration-progress"></div>
                </div>
                <div class="progress-text" id="calibration-progress-text">Step 1 of 4</div>
            </div>
        </div>

        <!-- Ready Screen -->
        <div class="screen" id="ready-screen">
            <h2>Calibration Complete!</h2>

            <div class="calibration-results">
                <h3>Your Breathing Profile</h3>
                <div class="result-row">
                    <span class="result-label">Inhale Duration:</span>
                    <span class="result-value" id="result-inhale">0.0s</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Exhale Duration:</span>
                    <span class="result-value" id="result-exhale">0.0s</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Target Inhale:</span>
                    <span class="result-value" id="result-target-in">4.0s</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Target Exhale:</span>
                    <span class="result-value" id="result-target-out">4.0s</span>
                </div>
                <div class="adjustment-hint" id="adjustment-hint"></div>
            </div>

            <p>You'll see two spheres:<br>
            <strong style="color: #8af;">Blue</strong> - Follow this guide<br>
            <strong style="color: #8f8;">Green</strong> - Your detected breathing</p>
            <p>We'll gradually adjust to help you reach the target pace.</p>
            <button class="btn" id="begin-meditation-btn">Start Meditation</button>
        </div>

        <!-- Meditation Screen -->
        <div class="screen" id="meditation-screen">
            <div class="round-counter" id="round-counter">Round 1 of 5</div>

            <div class="breathing-phase" id="breathing-phase">Get Ready...</div>

            <div class="spheres-container">
                <div class="sphere-wrapper">
                    <div class="sphere-label">Guide</div>
                    <div class="sphere guide" id="guide-sphere">
                        <div class="sphere-fill" id="guide-fill"></div>
                        <div class="sphere-glow"></div>
                    </div>
                </div>
                <div class="sphere-wrapper">
                    <div class="sphere-label">You</div>
                    <div class="sphere user" id="user-sphere">
                        <div class="sphere-fill" id="user-fill"></div>
                        <div class="sphere-glow"></div>
                    </div>
                </div>
            </div>

            <div class="timer" id="meditation-timer">4</div>

            <div class="talking-warning" id="talking-warning"></div>
            <div class="feedback" id="feedback"></div>

            <button class="btn secondary" id="stop-meditation-btn" style="margin-top: 20px;">End Session</button>
        </div>

        <!-- Completion Screen -->
        <div class="screen" id="completion-screen">
            <h2>Session Complete!</h2>
            <p>Wonderful job on completing your breathing meditation.</p>

            <div class="completion-stats">
                <div class="stat-item">
                    <div class="stat-value" id="stat-rounds">5</div>
                    <div class="stat-label">Rounds Completed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-duration">0:00</div>
                    <div class="stat-label">Total Duration</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-sync">0%</div>
                    <div class="stat-label">Average Sync</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-breaths">0</div>
                    <div class="stat-label">Total Breaths</div>
                </div>
            </div>

            <button class="btn" id="restart-btn">Start Again</button>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            targetInhaleDuration: 4000,     // ms - target
            targetExhaleDuration: 4000,     // ms - target
            holdDuration: 1000,             // ms between phases
            totalRounds: 5,
            calibrationDuration: 6000,      // ms per calibration step
            audioSmoothingFactor: 0.2,
            breathThresholdMultiplier: 1.5, // Above silence * this = breathing
            talkingVarianceThreshold: 0.02, // High variance = talking
            adaptationRate: 0.5             // How fast to adapt to target (0.5 = average)
        };

        // ============================================
        // STATE
        // ============================================
        const state = {
            audioContext: null,
            analyser: null,
            microphone: null,
            dataArray: null,
            calibration: {
                silence: { level: 0, variance: 0 },
                talking: { level: 0, variance: 0 },
                breathingIn: { level: 0, duration: 0 },
                breathingOut: { level: 0, duration: 0 }
            },
            // Breathing detection
            breathThreshold: 0.1,
            isBreathing: false,
            breathStartTime: 0,
            lastBreathDuration: 0,
            currentBreathPhase: 'idle', // 'in', 'out', 'idle'
            // User sphere animation
            userSpherePercent: 0,
            userSphereTarget: 0,
            userAnimationStart: 0,
            userAnimationDuration: 4000,
            // Adaptive timing
            currentInhaleDuration: 4000,
            currentExhaleDuration: 4000,
            // Session state
            currentPhase: 'idle',
            currentRound: 0,
            meditationStartTime: 0,
            syncScores: [],
            totalBreaths: 0,
            isListening: false,
            smoothedLevel: 0,
            // Recent audio samples for variance calculation
            recentSamples: [],
            maxRecentSamples: 20
        };

        // ============================================
        // AUDIO PROCESSING
        // ============================================
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioContext.createAnalyser();
                state.analyser.fftSize = 2048;
                state.analyser.smoothingTimeConstant = 0.8;

                state.microphone = state.audioContext.createMediaStreamSource(stream);
                state.microphone.connect(state.analyser);

                state.dataArray = new Uint8Array(state.analyser.frequencyBinCount);
                state.isListening = true;

                // Start audio monitoring loop
                monitorAudio();

                return true;
            } catch (error) {
                console.error('Audio init error:', error);
                return false;
            }
        }

        function getAudioLevel() {
            if (!state.analyser || !state.isListening) return 0;

            state.analyser.getByteFrequencyData(state.dataArray);

            // Calculate RMS with focus on breathing frequencies (100-500 Hz)
            const sampleRate = state.audioContext.sampleRate;
            const binSize = sampleRate / state.analyser.fftSize;
            const lowBin = Math.floor(100 / binSize);
            const highBin = Math.floor(500 / binSize);

            let sum = 0;
            let count = 0;

            for (let i = lowBin; i < highBin && i < state.dataArray.length; i++) {
                sum += state.dataArray[i] * state.dataArray[i];
                count++;
            }

            const rms = Math.sqrt(sum / count) / 255;

            // Smooth the level
            state.smoothedLevel = state.smoothedLevel * (1 - CONFIG.audioSmoothingFactor) +
                                  rms * CONFIG.audioSmoothingFactor;

            // Track recent samples for variance calculation
            state.recentSamples.push(state.smoothedLevel);
            if (state.recentSamples.length > state.maxRecentSamples) {
                state.recentSamples.shift();
            }

            return state.smoothedLevel;
        }

        function getCurrentVariance() {
            if (state.recentSamples.length < 5) return 0;
            const avg = state.recentSamples.reduce((a, b) => a + b, 0) / state.recentSamples.length;
            return state.recentSamples.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / state.recentSamples.length;
        }

        function isTalkingDetected() {
            const level = state.smoothedLevel;
            const variance = getCurrentVariance();
            const silenceLevel = state.calibration.silence.level;
            const talkingLevel = state.calibration.talking.level;
            const talkingVariance = state.calibration.talking.variance;

            // Talking has high level AND high variance (speech varies a lot)
            // Breathing has moderate level but lower, steadier variance
            const isHighLevel = level > (silenceLevel + talkingLevel) / 2;
            const isHighVariance = variance > talkingVariance * 0.5;

            return isHighLevel && isHighVariance;
        }

        function detectBreathingState(level) {
            const threshold = state.breathThreshold;
            const wasBreathing = state.isBreathing;

            state.isBreathing = level > threshold;

            // Detect breath start
            if (state.isBreathing && !wasBreathing) {
                state.breathStartTime = Date.now();
            }

            // Detect breath end
            if (!state.isBreathing && wasBreathing && state.breathStartTime > 0) {
                state.lastBreathDuration = Date.now() - state.breathStartTime;
            }

            return state.isBreathing;
        }

        function monitorAudio() {
            if (!state.isListening) return;

            const level = getAudioLevel();
            updateAudioLevelDisplay(level);

            requestAnimationFrame(monitorAudio);
        }

        function updateAudioLevelDisplay(level) {
            const fill = document.getElementById('audio-level-fill');
            if (fill) {
                fill.style.width = `${Math.min(level * 300, 100)}%`;
            }
        }

        // ============================================
        // TEXT TO SPEECH
        // ============================================
        function speak(text, callback) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.85;
                utterance.pitch = 1;
                utterance.volume = 0.8;

                // Try to find a calm, clear voice
                const voices = window.speechSynthesis.getVoices();
                const preferredVoice = voices.find(v =>
                    v.name.includes('Google') ||
                    v.name.includes('Samantha') ||
                    v.name.includes('Daniel')
                );
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }

                if (callback) {
                    utterance.onend = callback;
                }

                window.speechSynthesis.speak(utterance);
            } else {
                // Fallback: just call callback after estimated time
                if (callback) {
                    setTimeout(callback, text.length * 80);
                }
            }
        }

        // ============================================
        // CALIBRATION
        // ============================================
        async function runCalibration() {
            // Step 1: Silence
            await calibrateSilence();

            // Step 2: Talking
            await calibrateTalking();

            // Step 3: Breathing In
            await calibrateBreathingIn();

            // Step 4: Breathing Out
            await calibrateBreathingOut();

            // Calculate breath threshold
            state.breathThreshold = state.calibration.silence.level * CONFIG.breathThresholdMultiplier;

            // Show results and ready screen
            showCalibrationResults();
            showScreen('ready-screen');
        }

        function calibrateSilence() {
            return new Promise((resolve) => {
                document.getElementById('cal-silence-dot').classList.add('active');
                updateCalibrationProgress(1, 4);

                speak("Let's start by calibrating silence. Please remain quiet and still for a few seconds.", () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Stay quiet and still...";

                    const samples = [];
                    const startTime = Date.now();

                    const collect = () => {
                        if (Date.now() - startTime < CONFIG.calibrationDuration) {
                            samples.push(getAudioLevel());
                            setTimeout(collect, 50);
                        } else {
                            // Calculate average and variance
                            const avg = samples.reduce((a, b) => a + b, 0) / samples.length;
                            const variance = samples.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / samples.length;

                            state.calibration.silence = { level: avg, variance: variance };

                            document.getElementById('cal-silence-dot').classList.remove('active');
                            document.getElementById('cal-silence-dot').classList.add('complete');

                            speak("Good. Silence calibrated.", resolve);
                        }
                    };

                    setTimeout(collect, 500);
                });
            });
        }

        function calibrateTalking() {
            return new Promise((resolve) => {
                document.getElementById('cal-talking-dot').classList.add('active');
                updateCalibrationProgress(2, 4);

                speak("Now, please speak normally for a few seconds. Count from one to ten, or say anything you like.", () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Please speak now... (count 1 to 10)";

                    const samples = [];
                    const startTime = Date.now();

                    const collect = () => {
                        if (Date.now() - startTime < CONFIG.calibrationDuration) {
                            samples.push(getAudioLevel());
                            setTimeout(collect, 50);
                        } else {
                            const avg = samples.reduce((a, b) => a + b, 0) / samples.length;
                            const variance = samples.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / samples.length;

                            state.calibration.talking = { level: avg, variance: variance };

                            document.getElementById('cal-talking-dot').classList.remove('active');
                            document.getElementById('cal-talking-dot').classList.add('complete');

                            speak("Thank you. Now let's measure your breathing.", resolve);
                        }
                    };

                    setTimeout(collect, 500);
                });
            });
        }

        function calibrateBreathingIn() {
            return new Promise((resolve) => {
                document.getElementById('cal-breathin-dot').classList.add('active');
                updateCalibrationProgress(3, 4);

                speak("Take a slow, deep breath in through your nose. Start when you're ready and breathe in completely.", () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Breathe IN slowly... (we're measuring)";

                    // Wait for breath to start, then measure duration
                    let breathStarted = false;
                    let breathStartTime = 0;
                    let breathEndTime = 0;
                    let peakLevel = 0;
                    const samples = [];
                    const startTime = Date.now();
                    const maxWaitTime = 10000; // 10 seconds max

                    const tempThreshold = state.calibration.silence.level * 1.3;

                    const monitor = () => {
                        const level = getAudioLevel();
                        samples.push(level);

                        // Update sphere based on current level
                        const normalizedLevel = Math.min(1, Math.max(0,
                            (level - state.calibration.silence.level) /
                            (state.calibration.talking.level - state.calibration.silence.level + 0.01)
                        ));
                        setSpherePercent('calibration-fill', normalizedLevel * 100);

                        if (!breathStarted && level > tempThreshold) {
                            breathStarted = true;
                            breathStartTime = Date.now();
                        }

                        if (breathStarted) {
                            if (level > peakLevel) peakLevel = level;

                            // Check if breath ended (level dropped significantly from peak)
                            if (level < peakLevel * 0.4 && Date.now() - breathStartTime > 1000) {
                                breathEndTime = Date.now();
                                const duration = breathEndTime - breathStartTime;

                                state.calibration.breathingIn = {
                                    level: peakLevel,
                                    duration: duration
                                };

                                document.getElementById('timing-info').textContent =
                                    `Inhale detected: ${(duration / 1000).toFixed(1)} seconds`;

                                document.getElementById('cal-breathin-dot').classList.remove('active');
                                document.getElementById('cal-breathin-dot').classList.add('complete');

                                speak(`Good. Your inhale was ${(duration / 1000).toFixed(1)} seconds.`, resolve);
                                return;
                            }
                        }

                        if (Date.now() - startTime < maxWaitTime) {
                            setTimeout(monitor, 50);
                        } else {
                            // Timeout - use default
                            state.calibration.breathingIn = {
                                level: Math.max(...samples),
                                duration: 4000
                            };
                            document.getElementById('cal-breathin-dot').classList.remove('active');
                            document.getElementById('cal-breathin-dot').classList.add('complete');
                            speak("Using default timing. Let's continue.", resolve);
                        }
                    };

                    setTimeout(monitor, 500);
                });
            });
        }

        function calibrateBreathingOut() {
            return new Promise((resolve) => {
                document.getElementById('cal-breathout-dot').classList.add('active');
                updateCalibrationProgress(4, 4);

                // Reset sphere to full
                setSpherePercent('calibration-fill', 100);

                speak("Now slowly breathe out through your mouth. Start when you're ready.", () => {
                    document.getElementById('calibration-instruction').textContent =
                        "Breathe OUT slowly... (we're measuring)";

                    let breathStarted = false;
                    let breathStartTime = 0;
                    let peakLevel = 0;
                    const samples = [];
                    const startTime = Date.now();
                    const maxWaitTime = 10000;

                    const tempThreshold = state.calibration.silence.level * 1.3;

                    const monitor = () => {
                        const level = getAudioLevel();
                        samples.push(level);

                        // Update sphere - goes from 100 to 0 based on time since breath started
                        if (breathStarted) {
                            const elapsed = Date.now() - breathStartTime;
                            const estimatedDuration = 4000; // rough estimate
                            const percent = Math.max(0, 100 - (elapsed / estimatedDuration) * 100);
                            setSpherePercent('calibration-fill', percent);
                        }

                        if (!breathStarted && level > tempThreshold) {
                            breathStarted = true;
                            breathStartTime = Date.now();
                        }

                        if (breathStarted) {
                            if (level > peakLevel) peakLevel = level;

                            // Check if breath ended
                            if (level < peakLevel * 0.3 && Date.now() - breathStartTime > 1000) {
                                const duration = Date.now() - breathStartTime;

                                state.calibration.breathingOut = {
                                    level: peakLevel,
                                    duration: duration
                                };

                                setSpherePercent('calibration-fill', 0);

                                document.getElementById('timing-info').textContent =
                                    `Exhale detected: ${(duration / 1000).toFixed(1)} seconds`;

                                document.getElementById('cal-breathout-dot').classList.remove('active');
                                document.getElementById('cal-breathout-dot').classList.add('complete');

                                speak(`Your exhale was ${(duration / 1000).toFixed(1)} seconds. Calibration complete.`, resolve);
                                return;
                            }
                        }

                        if (Date.now() - startTime < maxWaitTime) {
                            setTimeout(monitor, 50);
                        } else {
                            state.calibration.breathingOut = {
                                level: Math.max(...samples),
                                duration: 4000
                            };
                            document.getElementById('cal-breathout-dot').classList.remove('active');
                            document.getElementById('cal-breathout-dot').classList.add('complete');
                            speak("Using default timing. Calibration complete.", resolve);
                        }
                    };

                    setTimeout(monitor, 500);
                });
            });
        }

        function showCalibrationResults() {
            const measuredIn = state.calibration.breathingIn.duration / 1000;
            const measuredOut = state.calibration.breathingOut.duration / 1000;
            const targetIn = CONFIG.targetInhaleDuration / 1000;
            const targetOut = CONFIG.targetExhaleDuration / 1000;

            document.getElementById('result-inhale').textContent = `${measuredIn.toFixed(1)}s`;
            document.getElementById('result-exhale').textContent = `${measuredOut.toFixed(1)}s`;
            document.getElementById('result-target-in').textContent = `${targetIn.toFixed(1)}s`;
            document.getElementById('result-target-out').textContent = `${targetOut.toFixed(1)}s`;

            // Calculate initial adaptive durations
            state.currentInhaleDuration = (state.calibration.breathingIn.duration + CONFIG.targetInhaleDuration) / 2;
            state.currentExhaleDuration = (state.calibration.breathingOut.duration + CONFIG.targetExhaleDuration) / 2;

            // Generate adjustment hint
            let hint = '';
            const inDiff = targetIn - measuredIn;
            const outDiff = targetOut - measuredOut;

            if (Math.abs(inDiff) < 0.5 && Math.abs(outDiff) < 0.5) {
                hint = "Your breathing pace is close to the target. Great!";
            } else {
                const parts = [];
                if (inDiff > 0.5) {
                    parts.push(`breathe in ${inDiff.toFixed(1)}s slower`);
                } else if (inDiff < -0.5) {
                    parts.push(`breathe in ${Math.abs(inDiff).toFixed(1)}s faster`);
                }
                if (outDiff > 0.5) {
                    parts.push(`breathe out ${outDiff.toFixed(1)}s slower`);
                } else if (outDiff < -0.5) {
                    parts.push(`breathe out ${Math.abs(outDiff).toFixed(1)}s faster`);
                }
                hint = `To match the target, try to ${parts.join(' and ')}.`;
            }

            document.getElementById('adjustment-hint').textContent = hint;

            // Speak the adjustment hint
            speak(hint);
        }

        function updateCalibrationProgress(step, total) {
            const progress = (step / total) * 100;
            document.getElementById('calibration-progress').style.width = `${progress}%`;
            document.getElementById('calibration-progress-text').textContent = `Step ${step} of ${total}`;
        }

        // ============================================
        // SPHERE ANIMATION
        // ============================================
        function setSpherePercent(fillId, percent) {
            const fill = document.getElementById(fillId);
            if (!fill) return;

            percent = Math.max(0, Math.min(100, percent));
            fill.style.height = `${percent}%`;

            if (percent > 90) {
                fill.style.borderRadius = '90px';
            } else {
                fill.style.borderRadius = '0 0 90px 90px';
            }
        }

        function animateSphere(fillId, fromPercent, toPercent, duration, callback) {
            const fill = document.getElementById(fillId);
            if (!fill) return;

            const startTime = Date.now();
            const startPercent = fromPercent;
            const endPercent = toPercent;

            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const currentPercent = startPercent + (endPercent - startPercent) * eased;
                setSpherePercent(fillId, currentPercent);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            };

            animate();
        }

        // User sphere animation based on detected breathing
        function startUserSphereAnimation(fromPercent, toPercent, duration) {
            state.userSpherePercent = fromPercent;
            state.userSphereTarget = toPercent;
            state.userAnimationStart = Date.now();
            state.userAnimationDuration = duration;
        }

        function updateUserSphereFromBreathing() {
            const elapsed = Date.now() - state.userAnimationStart;
            const progress = Math.min(elapsed / state.userAnimationDuration, 1);

            // Ease in-out
            const eased = progress < 0.5
                ? 2 * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            const currentPercent = state.userSpherePercent +
                (state.userSphereTarget - state.userSpherePercent) * eased;

            setSpherePercent('user-fill', currentPercent);

            return progress;
        }

        // ============================================
        // MEDITATION SESSION
        // ============================================
        async function startMeditation() {
            state.currentRound = 0;
            state.syncScores = [];
            state.totalBreaths = 0;
            state.meditationStartTime = Date.now();

            // Reset user sphere
            setSpherePercent('user-fill', 0);
            setSpherePercent('guide-fill', 0);

            showScreen('meditation-screen');
            document.getElementById('talking-warning').textContent = '';

            speak("Let's begin. Find a comfortable position and relax.", () => {
                setTimeout(() => runMeditationRound(), 2000);
            });
        }

        async function runMeditationRound() {
            state.currentRound++;

            if (state.currentRound > CONFIG.totalRounds) {
                endMeditation();
                return;
            }

            document.getElementById('round-counter').textContent =
                `Round ${state.currentRound} of ${CONFIG.totalRounds}`;
            document.getElementById('talking-warning').textContent = '';

            // Breathe In
            await breatheIn();

            // Brief hold
            await hold();

            // Breathe Out
            await breatheOut();

            // Brief hold
            await hold();

            state.totalBreaths++;

            // Adapt timing towards target for next round
            state.currentInhaleDuration = state.currentInhaleDuration +
                (CONFIG.targetInhaleDuration - state.currentInhaleDuration) * CONFIG.adaptationRate;
            state.currentExhaleDuration = state.currentExhaleDuration +
                (CONFIG.targetExhaleDuration - state.currentExhaleDuration) * CONFIG.adaptationRate;

            // Continue to next round
            setTimeout(() => runMeditationRound(), 500);
        }

        function breatheIn() {
            return new Promise((resolve) => {
                state.currentPhase = 'in';
                document.getElementById('breathing-phase').textContent = 'Breathe In...';

                speak("Breathe in");

                const duration = CONFIG.targetInhaleDuration;
                const userDuration = state.currentInhaleDuration;

                // Animate guide sphere (always at target pace)
                animateSphere('guide-fill', 0, 100, duration);

                // Start user sphere animation (at adaptive pace)
                startUserSphereAnimation(0, 100, userDuration);

                const syncSamples = [];
                const startTime = Date.now();
                let talkingDetectedThisPhase = false;

                const countdownInterval = setInterval(() => {
                    const remaining = Math.ceil((duration - (Date.now() - startTime)) / 1000);
                    document.getElementById('meditation-timer').textContent = Math.max(0, remaining);
                }, 100);

                const monitor = () => {
                    if (Date.now() - startTime < duration) {
                        getAudioLevel(); // Update audio state

                        // Check for talking
                        if (isTalkingDetected()) {
                            document.getElementById('talking-warning').textContent =
                                'Talking detected - please concentrate on breathing';
                            talkingDetectedThisPhase = true;
                        } else if (!talkingDetectedThisPhase) {
                            document.getElementById('talking-warning').textContent = '';
                        }

                        // Update user sphere based on time (smooth animation)
                        const userProgress = updateUserSphereFromBreathing();

                        // Calculate guide progress for sync scoring
                        const guideProgress = (Date.now() - startTime) / duration;
                        syncSamples.push(Math.abs(userProgress - guideProgress));

                        setTimeout(monitor, 50);
                    } else {
                        clearInterval(countdownInterval);

                        // Ensure spheres are at 100%
                        setSpherePercent('user-fill', 100);

                        // Calculate sync score
                        const avgDiff = syncSamples.reduce((a, b) => a + b, 0) / syncSamples.length;
                        const syncScore = Math.max(0, 100 - avgDiff * 200);
                        state.syncScores.push(syncScore);

                        updateFeedback(syncScore);
                        resolve();
                    }
                };

                monitor();
            });
        }

        function breatheOut() {
            return new Promise((resolve) => {
                state.currentPhase = 'out';
                document.getElementById('breathing-phase').textContent = 'Breathe Out...';

                speak("Breathe out");

                const duration = CONFIG.targetExhaleDuration;
                const userDuration = state.currentExhaleDuration;

                // Animate guide sphere (always at target pace)
                animateSphere('guide-fill', 100, 0, duration);

                // Start user sphere animation (at adaptive pace, going from 100 to 0)
                startUserSphereAnimation(100, 0, userDuration);

                const syncSamples = [];
                const startTime = Date.now();
                let talkingDetectedThisPhase = false;

                const countdownInterval = setInterval(() => {
                    const remaining = Math.ceil((duration - (Date.now() - startTime)) / 1000);
                    document.getElementById('meditation-timer').textContent = Math.max(0, remaining);
                }, 100);

                const monitor = () => {
                    if (Date.now() - startTime < duration) {
                        getAudioLevel();

                        // Check for talking
                        if (isTalkingDetected()) {
                            document.getElementById('talking-warning').textContent =
                                'Talking detected - please concentrate on breathing';
                            talkingDetectedThisPhase = true;
                        } else if (!talkingDetectedThisPhase) {
                            document.getElementById('talking-warning').textContent = '';
                        }

                        // Update user sphere (smooth animation from 100 to 0)
                        updateUserSphereFromBreathing();

                        // For sync scoring
                        const userProgress = (Date.now() - state.userAnimationStart) / state.userAnimationDuration;
                        const guideProgress = (Date.now() - startTime) / duration;
                        syncSamples.push(Math.abs(userProgress - guideProgress));

                        setTimeout(monitor, 50);
                    } else {
                        clearInterval(countdownInterval);

                        // Ensure spheres are at 0%
                        setSpherePercent('user-fill', 0);

                        const avgDiff = syncSamples.reduce((a, b) => a + b, 0) / syncSamples.length;
                        const syncScore = Math.max(0, 100 - avgDiff * 200);
                        state.syncScores.push(syncScore);

                        updateFeedback(syncScore);
                        resolve();
                    }
                };

                monitor();
            });
        }

        function hold() {
            return new Promise((resolve) => {
                state.currentPhase = 'hold';
                document.getElementById('breathing-phase').textContent = 'Hold...';
                document.getElementById('meditation-timer').textContent = '...';
                document.getElementById('talking-warning').textContent = '';
                setTimeout(resolve, CONFIG.holdDuration);
            });
        }

        function updateFeedback(score) {
            const feedback = document.getElementById('feedback');
            if (score > 80) {
                feedback.textContent = 'Excellent! Keep it up!';
                feedback.style.color = '#8f8';
            } else if (score > 60) {
                feedback.textContent = 'Good rhythm!';
                feedback.style.color = '#afc';
            } else if (score > 40) {
                feedback.textContent = 'Try to match the guide';
                feedback.style.color = '#ffa';
            } else {
                feedback.textContent = 'Follow the blue sphere';
                feedback.style.color = '#faa';
            }
        }

        function endMeditation() {
            const duration = Math.floor((Date.now() - state.meditationStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;

            const avgSync = state.syncScores.length > 0
                ? Math.round(state.syncScores.reduce((a, b) => a + b, 0) / state.syncScores.length)
                : 0;

            document.getElementById('stat-rounds').textContent = state.currentRound - 1;
            document.getElementById('stat-duration').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('stat-sync').textContent = `${avgSync}%`;
            document.getElementById('stat-breaths').textContent = state.totalBreaths;

            speak("Wonderful. You've completed your meditation session. Take a moment to notice how you feel.");

            showScreen('completion-screen');
        }

        // ============================================
        // SCREEN NAVIGATION
        // ============================================
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        // ============================================
        // STAR FIELD
        // ============================================
        function createStarfield() {
            const container = document.getElementById('stars');
            const starCount = 150;

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.width = `${Math.random() * 3 + 1}px`;
                star.style.height = star.style.width;
                star.style.animationDelay = `${Math.random() * 3}s`;
                container.appendChild(star);
            }
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        document.getElementById('start-btn').addEventListener('click', () => {
            showScreen('permission-screen');
        });

        document.getElementById('permission-btn').addEventListener('click', async () => {
            const btn = document.getElementById('permission-btn');
            btn.disabled = true;
            btn.textContent = 'Requesting access...';

            const success = await initAudio();

            if (success) {
                showScreen('calibration-screen');
                // Wait for voices to load
                setTimeout(() => runCalibration(), 1000);
            } else {
                document.getElementById('permission-error').style.display = 'block';
                document.getElementById('permission-error').textContent =
                    'Could not access microphone. Please allow microphone access and try again.';
                btn.disabled = false;
                btn.textContent = 'Try Again';
            }
        });

        document.getElementById('begin-meditation-btn').addEventListener('click', () => {
            startMeditation();
        });

        document.getElementById('stop-meditation-btn').addEventListener('click', () => {
            state.currentRound = CONFIG.totalRounds + 1;
            endMeditation();
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            // Reset adaptive timing
            state.currentInhaleDuration = (state.calibration.breathingIn.duration + CONFIG.targetInhaleDuration) / 2;
            state.currentExhaleDuration = (state.calibration.breathingOut.duration + CONFIG.targetExhaleDuration) / 2;
            showScreen('ready-screen');
        });

        // Load voices
        if ('speechSynthesis' in window) {
            window.speechSynthesis.getVoices();
            window.speechSynthesis.onvoiceschanged = () => {
                window.speechSynthesis.getVoices();
            };
        }

        // Initialize
        createStarfield();
    </script>
</body>
</html>
